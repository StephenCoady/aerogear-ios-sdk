= AeroGear Services Auth SDK

Mobile authentication SDK based on link:http://www.keycloak.org/[Keycloak] using link:http://openid.net/connect/[OpenID Connect].

== Usage

To use the Auth SDK you'll first need to:

* Have a Keycloak instance.
* Import the Core module. See link:./core/README.adoc[the Core documentation].
* A configuration file added to the app directory. See the <<Configuration File>> section.

=== Adding Dependency

Add dependency to your Podfile:

```
pod 'AGSAuth'
```

=== Configuration File

A `mobile-services.json` file must exist in the app directory. It should specify configuration
for Keycloak. This configuration can be generated by the link:https://github.com/aerogear/mobile-cli[AeroGear Mobile CLI].

For an example of Keycloak configuration see the example apps link:../../example/AeroGearSdkExample/mobile-services.json[mobile-services.json].

The Auth SDK will use this configuration to communicate with Keycloak.

=== Initializing the SDK
The Auth SDK can be initialised with configuration options. The redirect URL should match the App's Bundle Identifier.

[source,swift]
----
// create the authentication config
let authenticationConfig = AuthenticationConfig(redirectURL: "org.aerogear.mobile.example:/callback")
try! AgsAuth.instance.configure(authConfig: authenticationConfig)
----

=== Retrieving the Current User
The current authenticated user can be retrieved using the `currentUser()` method.
This function can be be used to check whether to start the authentication flow or not if the user is not authenticated.

[source,swift]
----
do {
    guard let currentUser = try AgsAuth.instance.currentUser() else {
        // user not authenticated, start authentication flow
        return
    }
    // Get the users username
    let username = currentUser.userName
    // Get the users first name
    let firstName = currentUser.firstName
    // Get the users last name
    let lastName = currentUser.lastName
    // Get the users full name
    let fullName = currentUser.fullName
    // Get the users email address
    let emailAddress = currentUser.email
    // Get the users access token
    let accessToken = currentUser.accessToken
    // Get the users identity token
    let identityToken = currentUser.identityToken
} catch {
    fatalError("Error Retrieving User: \(error).")
}
----

=== Authenticating
The authentication flow can be triggered using the `login()` function which provided a callback.

[source,swift]
----
// start the authentication flow
try AgsAuth.instance.login(presentingViewController: self, onCompleted: onLoginComplete)

...

// handle the authentication result
func onLoginComplete(user: User?, err: Error?) {
    // login failed
    if let error = err {
        // login error
        return
    }
    // login succeeded
    let currentUser = user
    ...
}
----

In your app's https://developer.apple.com/documentation/uikit/uiapplicationdelegate[AppDelegate], you will need to allow your application to handle the redirect.

[source,swift]
----
// handle the redirect from the browser
func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey: Any] = [:]) -> Bool {
    do {
        return try AgsAuth.instance.resumeAuth(url: url as URL)
    } catch AgsAuth.Errors.serviceNotConfigured {
        print("AeroGear auth service is not configured")
    } catch {
        fatalError("Unexpected error: \(error).")
    }
    return false
}
----

=== Retrieving a Users Roles
Once a User has been retrieved, the roles of the user can be listed and checked. This can be used to perform client side access control.

Roles are divided into two types. Client roles which belong to the client the user has authenticated against, and Realm roles which belong to the realm the client is in.

The users roles are available on the authenticated user.

[source,swift]
----
// client roles
let clientRoles = currentUser.clientRoles
// realm roles
let realmRoles = currentUser.realmRoles
----

In order to check if a user has a specific role you can invoke the `hasClientRole()` and `hasRealmRole() methods and provide the role name to check for.

[source,swift]
----
// check if the user has a given realm role
let hasAdminRole = currentUser.hasRealmRole("admin")
if (hasAdminRole) {
  // user has the admin role
}

// check if the user has a given client role
let hasModeratorRole = currentUser.hasClientRole(client: "my_client", role: "moderator")
if (hasModeratorRole) {
  // user has the moderator role in my_client
}
----

=== Logging Out

To logout, invoke the `logout()` method.

[source,swift]
----
do {
    try AgsAuth.instance.logout(onCompleted: self.onLogoutComplete)
} catch {
    fatalError("Error logging out: \(error).")
}
----

Then handle the logout logic.

[source,swift]
----
func onLogoutComplete(_: Error?) {
    // handle logout
}
----

*Note:* To perform backchannel or federated logouts, you must enable the Backchannel Logout option for the federated identity provider. More information is available in the Keycloak documentation under  http://www.keycloak.org/docs/latest/server_admin/index.html#openid-connect-v1-0-identity-providers[OIDC Identity Providers].
